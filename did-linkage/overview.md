# DID Linkage

We want to link a Verida DID to an existing blockchain address. This provides some important benefits:

- Users can discover each other by public blockchain address, rather than solely relying on Verida account identifiers (DID's). This has the potential to greatly improve the UX for dApps developed on the Verida network.
- Blockchains can cryptographically prove a Verida account controls a blockchain address, so can then trust off chain data signed by that Verida account. This has many use cases for bringing off-chain data, on-chain.
- Users can prove (publicly or privately) that they control 1 or more blockchain addresses. This has many use cases in DeFi.

## User stories

- As a Verida Account I can cryptographically prove I control a public blockchain address
- As a Verida Account I can privately share that I control a public blockchain address
- As a Verida Account I can publicly share that I control a public blockchain address
- As a Verida Account my decentralized identity (DID) can be discoverable by one or many public blockchain addresses I control
- As a Developer I can interact with public blockchain addresses that are seamlessly re-routed to a linked Verida Account
- As a Smart Contract I can verify a signed consent message that proves a Verida account controls a blockchain account, so I can then trust data signed by that Verida account

## Implementation overview

### Client library

A typescript client library will be developed that supports the creation of a signed consent message linking a Verida account with a public blockchain address (assertation). The signed consent message needs to consider the following criteria:

- Compact size (to reduce storage size) and easy to validate (low cost) on public blockchains
- Signature scheme must be supported by each public blockchain. May need to support multiple signature schemes, depending on what each chain supports.
- Ideally a standards compliant proof is also generated, although this will need to be an extra step

#### Compact signature

A `compact consent message` (a `string` generated by the client library) will be constructed in the following format:

`This address (${caipAddress}) is controlled by ${did}`

An example consent message:

`This address (eip155:1:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb) is controlled by did:vda:0x9c26a96d359ec26a11e2c2b3d8f8b8942d5bfb19`

The user will then be prompted to sign this consent message using their private key (via WalletConnect, Metamask or the Verida Vault) to produce a `signed consent message`.

This `signed compact consent message` can then be stored in the user's private storage or made public via the Server API in the following format:

`${did},${capiAddress},${compactConsentMessage}`

#### Standards compliant proof

It's intended that a Verifiable Credential is generated and then signed by the blockchain address.

This is out of scope for now.

### Server API

A public server API will provide a public registry of linkages between Verida accounts (DIDs) and public blockchain addresses.

API endpoints:

- `addLink(signedCompactConsentMessage)` -- Register a new link between a Verida account and a public blockchain address
- `removeLink(signedCompactConsentMessage)` -- Remove a link between a Verida account and a public blockchain address
- `getLinks(did)` -- Get a list of all public blockchain addresses linked to a Verida account (ie: `did:vda:0x9c26a96d359ec26a11e2c2b3d8f8b8942d5bfb19`)
- `lookupDid(capiAddress)` -- Given a CAPI compliant address (ie: `eip155:1:0xab16a96d359ec26a11e2c2b3d8f8b8942d5bfcdb`) return the linked Verida account if there is a linkage

#### Authorization

- All requests to endpoints must include a recent signature from a Verida account. This signature should combine the method being called, the method parameters and a timestamp within the last 60 seconds (?)
- Requests made to `addLink()` and `removeLink()` must be signed by the Verida account making the request

### Web application

A web application needs to be developed that allows a user to:

- Connect the app to the Verida Vault
- Prompt a user which blockchain they wish to link to their Verida account
- Use the client library to generate a consent message
- Use an appropriate blockchain client SDK library (ie: WalletConnect, Metamask) prompting the user to sign the consent message
- Prompt the user to save the linkage in their private storage
- Prompt the user to save the linkage to the public DID linkage service

## Details Flow

* TBC

## Blockchains supported

We want to support the following blockchains, in order:

* Algorand (Note: There is no Algorand CAPI definition, but a [draft exists here](https://github.com/ChainAgnostic/CAIPs/issues/54)))
* Ethereum
* NEAR (Note: There is no NEAR CAPI definition, but a [draft exists here](https://github.com/ChainAgnostic/CAIPs/pull/43)))
* BTC
* _TBC_

## Development roadmap

1. Develop a consent prototype:
   1. Allows a user to sign in using Verida
   2. Allows a user to sign a consent message with a blockchain
   3. Allows a user to save their consent message to a private Verida database
1. Develop a discovery prototype:
   1. Allows a user to register their signed consent message in a public Verida API
   2. Takes the signed doc from the UX and stores it against the blockchain address
   3. Allows an application developer to lookup a blockchain address and discover any linked Verida account
   4. Allows an application developer to verify the cryptographic proof linking the blockchain address with the Verida account

## Also see

### Server implementations

We have already developed several Node.js API's that can be used as a quick starting point:

- [DID server](https://github.com/verida/did-server) -- Typescript, Express, CouchDb for storage
- [Storage node](https://github.com/verida/storage-node) -- Javascript, Express, CouchDb for storage.
  - This uses the `express-basic-auth` library to verify a signature header in every request. [See here](https://github.com/verida/storage-node/blob/main/src/middleware/requestValidator.js).
  - The configuration of which routes require that validation is [configured in server.js](https://github.com/verida/storage-node/blob/e041ac303c16f297521386bb950b804a974577b1/src/server.js#L24). (Note that `/user/public` doesn't require any authorization, so is added prior to configuring `basicAuth`)

I recommend using the `DID server` as the starting point for this `DID linkage server` as it has typescript already configured. Then pull across the `express-basic-auth` functionality to validate each request.

### Chain Agnostic Standards Alliance (CASA)

The Chain Agnostic Standards Alliance (CASA) is a collection of working groups dedicated blockchain protocol-agnostic standards. CASA also publishes [Chain Agnostic Improvement Proposals](https://github.com/ChainAgnostic/CAIPs) which describe standards created by the different working groups.

It makes sense that we leverage this standard for referencing a blockchain address in our consent message.

Relevant links:

- [Ethereum namespace (EIP155)](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-3.md)
- [Bitcoin namespace (BIP2122)](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-4.md)
- [Account specification](https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-10.md)

[There is a CAIP javascript helper library here](https://github.com/ChainAgnostic/caip-js)
